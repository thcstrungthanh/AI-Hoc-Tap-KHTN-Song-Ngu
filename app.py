from flask import Flask, render_template, request, jsonify, session, redirect, url_for, flash, send_file
from werkzeug.security import generate_password_hash, check_password_hash
import google.generativeai as genai
import PyPDF2
import re
from dotenv import load_dotenv
load_dotenv()
import os
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import time
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from sqlalchemy.sql import text
import pandas as pd
from io import BytesIO
from werkzeug.utils import secure_filename
# ================== C·∫§U H√åNH & KH·ªûI T·∫†O ==================
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("‚ùå Kh√¥ng t√¨m th·∫•y GEMINI_API_KEY trong bi·∫øn m√¥i tr∆∞·ªùng!")

genai.configure(api_key=api_key)

GENERATION_MODEL = 'gemini-2.5-flash-lite'
EMBEDDING_MODEL = 'text-embedding-004'

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY")
app.config["SESSION_TYPE"] = "filesystem"
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
migrate = Migrate(app, db)
Session(app)
# C·∫•u h√¨nh upload folder cho PDF
UPLOAD_FOLDER = './static'
ALLOWED_EXTENSIONS = {'pdf'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Gi·ªõi h·∫°n 16MB

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

class User(db.Model):
    __tablename__ = 'taikhoan_hocsinh'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)
    name = db.Column(db.Text, default='')
    level = db.Column(db.String(20), default='TB')
    history = db.Column(db.Text, default='')
    lydo = db.Column(db.Text, default='')

with app.app_context():
    # ƒê·∫£m b·∫£o schema public t·ªìn t·∫°i
    db.session.execute(text('CREATE SCHEMA IF NOT EXISTS public;'))
    db.create_all()
    print("‚úÖ ƒê√£ ki·ªÉm tra/t·∫°o b·∫£ng taikhoan_hocsinh trong schema public")

# Bi·∫øn to√†n c·ª•c cho RAG
RAG_DATA = {
    "chunks": [],
    "embeddings": np.array([]),
    "is_ready": False
}

# ================== ƒê·ªåC & CHIA CHUNKS ==================
def extract_pdf_text(pdf_path):
    text = ""
    try:
        with open(pdf_path, 'rb') as f:
            reader = PyPDF2.PdfReader(f)
            for page in reader.pages:
                text += page.extract_text() or ""
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi ƒë·ªçc PDF {pdf_path}: {e}")
    return text

def create_chunks_from_directory(directory='./static', chunk_size=400):
    all_chunks = []
    if not os.path.exists(directory):
        print(f"Th∆∞ m·ª•c {directory} kh√¥ng t·ªìn t·∫°i.")
        return []
    pdf_files = [f for f in os.listdir(directory) if f.endswith('.pdf')]
    print(f"üîç T√¨m th·∫•y {len(pdf_files)} t·ªáp PDF trong {directory}...")
    for filename in pdf_files:
        pdf_path = os.path.join(directory, filename)
        content = extract_pdf_text(pdf_path)
        for i in range(0, len(content), chunk_size):
            chunk = content[i:i + chunk_size].strip()
            if chunk:
                all_chunks.append(f"[Ngu·ªìn: {filename}] {chunk}")
    print(f"‚úÖ ƒê√£ t·∫°o t·ªïng c·ªông {len(all_chunks)} ƒëo·∫°n vƒÉn (chunks).")
    return all_chunks

def embed_with_retry(texts, model_name, max_retries=5):
    all_embeddings = []
    for text in texts:
        for attempt in range(max_retries):
            try:
                result = genai.embed_content(model=model_name, content=text)
                all_embeddings.append(result["embedding"])
                break
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"‚ö†Ô∏è Th·ª≠ l·∫°i l·∫ßn {attempt+1}: {e}")
                    time.sleep(2 ** attempt)
                else:
                    print(f"üí• Th·∫•t b·∫°i sau {max_retries} l·∫ßn: {e}")
                    raise
    return np.array(all_embeddings)

def initialize_rag_data():
    global RAG_DATA
    print("‚è≥ ƒêang kh·ªüi t·∫°o d·ªØ li·ªáu RAG...")
    chunks = create_chunks_from_directory()
    if not chunks:
        print("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ nh√∫ng.")
        return
    try:
        embeddings = embed_with_retry(chunks, EMBEDDING_MODEL)
        RAG_DATA.update({
            "chunks": chunks,
            "embeddings": embeddings,
            "is_ready": True
        })
        print("üéâ Kh·ªüi t·∫°o RAG ho√†n t·∫•t!")
    except Exception as e:
        print(f"‚ùå KH√îNG TH·ªÇ KH·ªûI T·∫†O RAG: {e}")
        RAG_DATA["is_ready"] = False

initialize_rag_data()

# ================== TRUY XU·∫§T NG·ªÆ C·∫¢NH ==================
def retrieve_context(query, top_k=3):
    if not RAG_DATA["is_ready"]:
        return "Kh√¥ng c√≥ t√†i li·ªáu RAG n√†o ƒë∆∞·ª£c t·∫£i."
    try:
        query_vec = embed_with_retry([query], EMBEDDING_MODEL)[0].reshape(1, -1)
        sims = cosine_similarity(query_vec, RAG_DATA["embeddings"])[0]
        top_idxs = np.argsort(sims)[-top_k:][::-1]
        return "\n\n---\n\n".join([RAG_DATA["chunks"][i] for i in top_idxs])
    except Exception as e:
        print(f"‚ùå L·ªói RAG: {e}")
        return "L·ªói khi t√¨m ki·∫øm ng·ªØ c·∫£nh."

# ================== ƒê√ÅNH GI√Å NƒÇNG L·ª∞C ==================
def evaluate_student_level(history):
    recent_questions = "\n".join([msg for msg in history[-10:] if msg.startswith("üëß H·ªçc sinh:")])
    prompt = f"""
    B·∫°n l√† m·ªôt **Gi√°o vi√™n Khoa h·ªçc T·ª± nhi√™n Song ng·ªØ (Anh ‚Äì Vi·ªát)**, c√≥ nhi·ªám v·ª• **ƒë√°nh gi√° nƒÉng l·ª±c h·ªçc t·∫≠p v√† kh·∫£ nƒÉng t·ª± h·ªçc c·ªßa h·ªçc sinh** d·ª±a tr√™n l·ªãch s·ª≠ c√¢u h·ªèi g·∫ßn ƒë√¢y.

    D∆∞·ªõi ƒë√¢y l√† **10 c√¢u h·ªèi g·∫ßn nh·∫•t c·ªßa h·ªçc sinh**:
    {recent_questions}

    ### üéØ Y√™u c·∫ßu:
    1. ƒê·ªçc k·ªπ n·ªôi dung c√°c c√¢u h·ªèi, x√°c ƒë·ªãnh:
    - M·ª©c ƒë·ªô hi·ªÉu bi·∫øt c·ªßa h·ªçc sinh v·ªÅ c√°c m√¥n **To√°n, L√Ω, H√≥a, Sinh**.
    - Kh·∫£ nƒÉng **di·ªÖn ƒë·∫°t logic**, **s·ª≠ d·ª•ng thu·∫≠t ng·ªØ khoa h·ªçc**, **t·ª± t√¨m hi·ªÉu**.
    - M·ª©c ƒë·ªô s·ª≠ d·ª•ng **song ng·ªØ Anh ‚Äì Vi·ªát**: ƒë√∫ng, sai, ho·∫∑c thi·∫øu t·ª± nhi√™n.
    2. Ph√¢n lo·∫°i nƒÉng l·ª±c h·ªçc t·∫≠p t·ªïng qu√°t th√†nh **m·ªôt trong 4 c·∫•p ƒë·ªô**:
    - **Gi·ªèi (Gioi)** ‚Üí h·ªèi c√°c v·∫•n ƒë·ªÅ n√¢ng cao, di·ªÖn ƒë·∫°t logic, d√πng ti·∫øng Anh ƒë√∫ng ng·ªØ c·∫£nh h·ªçc thu·∫≠t, th·ªÉ hi·ªán t∆∞ duy ph·∫£n bi·ªán.
    - **Kh√° (Kha)** ‚Üí h·ªèi ·ªü m·ª©c kh√°, hi·ªÉu kh√°i ni·ªám c∆° b·∫£n, c√≥ th·ªÉ sai nh·∫π nh∆∞ng di·ªÖn ƒë·∫°t t·ªët.
    - **Trung b√¨nh (TB)** ‚Üí h·ªèi nh·ªØng ki·∫øn th·ª©c c∆° b·∫£n, c√≤n sai s√≥t khi d√πng thu·∫≠t ng·ªØ ho·∫∑c c√¢u h·ªèi ch∆∞a r√µ.
    - **Y·∫øu (Yeu)** ‚Üí h·ªèi l·∫∑p l·∫°i, di·ªÖn ƒë·∫°t k√©m, kh√¥ng n·∫Øm ch·∫Øc kh√°i ni·ªám, ch∆∞a t·ª± gi·∫£i th√≠ch ƒë∆∞·ª£c v·∫•n ƒë·ªÅ.
    3. N·∫øu h·ªçc sinh xen k·∫Ω nhi·ªÅu m√¥n kh√°c nhau (VD: To√°n v√† Sinh), h√£y **ƒë√°nh gi√° trung b√¨nh t·ªïng h·ª£p**, kh√¥ng thi√™n l·ªách m·ªôt m√¥n.
    4. Vi·∫øt k·∫øt qu·∫£ ng·∫Øn g·ªçn, c√≥ l√Ω do s√∫c t√≠ch.

    ### üìã ƒê·ªãnh d·∫°ng ƒë·∫ßu ra:
    C·∫•p ƒë·ªô: [Gioi / Kha / TB / Yeu]  
    L√Ω do: [Gi·∫£i th√≠ch l√Ω do r√µ r√†ng, ph√¢n t√≠ch ƒë·ªãnh h∆∞·ªõng cho gi√°o vi√™n h·ªó tr·ª£, t·ªëi ƒëa 150‚Äì200 t·ª´.]
    """

    try:
        model = genai.GenerativeModel(GENERATION_MODEL)
        response = model.generate_content(prompt)
        response_text = response.text.strip()
        # Extract level and reason from response
        level_match = re.search(r'C·∫•p ƒë·ªô: (Gioi|Kha|TB|Yeu)', response_text)
        lydo_match = re.search(r'L√Ω do: (.+)', response_text, re.DOTALL)
        
        level = level_match.group(1) if level_match else "TB"
        lydo = lydo_match.group(1).strip() if lydo_match else "Kh√¥ng c√≥ l√Ω do c·ª• th·ªÉ."
        
        if level not in ['Gioi', 'Kha', 'TB', 'Yeu']:
            level = 'TB'
        return level, lydo
    except Exception as e:
        print(f"‚ùå L·ªói ƒë√°nh gi√°: {e}")
        return 'TB', 'ƒê√°nh gi√° kh√¥ng th√†nh c√¥ng do l·ªói h·ªá th·ªëng.'


# ================== ƒê·ªäNH D·∫†NG TR·∫¢ L·ªúI ==================
def format_response(response):
    # B·∫£o v·ªá c√∫ ph√°p LaTeX b·∫±ng c√°ch t·∫°m th·ªùi thay th·∫ø
    latex_matches = []
    def store_latex(match):
        latex_matches.append(match.group(0))
        return f"__LATEX_{len(latex_matches)-1}__"
    
    # Thay th·∫ø c√°c ƒëo·∫°n LaTeX n·ªôi d√≤ng ($...$) v√† ƒë·ªôc l·∫≠p ($$...$$)
    response = re.sub(r'\$\$([^$]+)\$\$', store_latex, response)
    response = re.sub(r'\$([^$]+)\$', store_latex, response)

    # √Åp d·ª•ng ƒë·ªãnh d·∫°ng Markdown
    formatted = re.sub(r'\*\*(.*?)\*\*', r'<strong style="font-weight:700;">\1</strong>', response)
    formatted = re.sub(r'(?<!\n)\*(?!\s)(.*?)(?<!\s)\*(?!\*)', r'<em style="font-style:italic;">\1</em>', formatted)
    formatted = re.sub(r'(?m)^\s*\*\s+(.*)', r'‚Ä¢ <span style="line-height:1.6;">\1</span>', formatted)
    formatted = formatted.replace('\n', '<br>')

    # √Åp d·ª•ng highlight_terms cho c√°c t·ª´ kh√≥a to√°n h·ªçc
    for term, color in highlight_terms.items():
        formatted = formatted.replace(term, f'<span style="line-height:1.6; background:{color}; color:white; font-weight:bold; padding:2px 4px; border-radius:4px;">{term}</span>')

    # Kh√¥i ph·ª•c c√∫ ph√°p LaTeX
    for i, latex in enumerate(latex_matches):
        formatted = formatted.replace(f"__LATEX_{i}__", latex)

    return formatted

# FORMAT TR·∫¢ L·ªúI
highlight_terms = {
    # üßÆ TO√ÅN H·ªåC
    "S·ªë t·ª± nhi√™n": "#59C059",
    "S·ªë nguy√™n": "#59C059",
    "S·ªë h·ªØu t·ªâ": "#59C059",
    "S·ªë th·∫≠p ph√¢n": "#59C059",
    "Ph√¢n s·ªë": "#59C059",
    "T·ªâ s·ªë ‚Äì T·ªâ l·ªá": "#59C059",
    "T·ªâ l·ªá thu·∫≠n ‚Äì T·ªâ l·ªá ngh·ªãch": "#59C059",
    "Bi·ªÉu th·ª©c ƒë·∫°i s·ªë": "#59C059",
    "H·∫±ng ƒë·∫≥ng th·ª©c ƒë√°ng nh·ªõ": "#59C059",
    "Nh√¢n, chia ƒëa th·ª©c": "#59C059",
    "Ph√¢n t√≠ch ƒëa th·ª©c th√†nh nh√¢n t·ª≠": "#59C059",
    "CƒÉn b·∫≠c hai, cƒÉn b·∫≠c ba": "#59C059",
    "L≈©y th·ª´a ‚Äì CƒÉn th·ª©c": "#59C059",
    "Gi·∫£i ph∆∞∆°ng tr√¨nh": "#59C059",
    "Ph∆∞∆°ng tr√¨nh b·∫≠c nh·∫•t m·ªôt ·∫©n": "#59C059",
    "H·ªá ph∆∞∆°ng tr√¨nh b·∫≠c nh·∫•t hai ·∫©n": "#59C059",
    "B·∫•t ph∆∞∆°ng tr√¨nh": "#59C059",
    "H√†m s·ªë ‚Äì ƒê·ªì th·ªã h√†m s·ªë": "#59C059",
    "H√†m s·ªë b·∫≠c nh·∫•t": "#59C059",
    "T·ªça ƒë·ªô trong m·∫∑t ph·∫≥ng": "#59C059",
    "ƒê·ªãnh l√Ω Pythagoras": "#59C059",
    "Chu vi ‚Äì Di·ªán t√≠ch ‚Äì Th·ªÉ t√≠ch": "#59C059",
    "Tam gi√°c": "#59C059",
    "H√¨nh tr√≤n ‚Äì H√¨nh c·∫ßu": "#59C059",

    # ‚ö° V·∫¨T L√ù
    "V·∫≠n t·ªëc": "#E8B33F",
    "Qu√£ng ƒë∆∞·ªùng": "#E8B33F",
    "Th·ªùi gian": "#E8B33F",
    "L·ª±c": "#E8B33F",
    "Tr·ªçng l·ª±c": "#E8B33F",
    "Kh·ªëi l∆∞·ª£ng": "#E8B33F",
    "Tr·ªçng l∆∞·ª£ng": "#E8B33F",
    "√Åp su·∫•t": "#E8B33F",
    "C√¥ng c∆° h·ªçc": "#E8B33F",
    "Nhi·ªát nƒÉng": "#E8B33F",
    "C√¥ng su·∫•t": "#E8B33F",
    "Nhi·ªát l∆∞·ª£ng": "#E8B33F",
    "D·∫´n nhi·ªát": "#E8B33F",
    "ƒê·ªëi l∆∞u": "#E8B33F",
    "B·ª©c x·∫° nhi·ªát": "#E8B33F",
    "ƒêi·ªán t√≠ch": "#E8B33F",
    "C∆∞·ªùng ƒë·ªô d√≤ng ƒëi·ªán": "#E8B33F",
    "Hi·ªáu ƒëi·ªán th·∫ø": "#E8B33F",
    "ƒêi·ªán tr·ªü": "#E8B33F",
    "ƒê·ªãnh lu·∫≠t √îm": "#E8B33F",
    "C√¥ng c·ªßa d√≤ng ƒëi·ªán": "#E8B33F",
    "C√¥ng su·∫•t ƒëi·ªán": "#E8B33F",
    "T·ª´ tr∆∞·ªùng": "#E8B33F",
    "Nam ch√¢m": "#E8B33F",
    "Th·∫•u k√≠nh h·ªôi t·ª•": "#E8B33F",
    "·∫¢nh th·∫≠t ‚Äì ·∫¢nh ·∫£o": "#E8B33F",
    "Ph·∫£n x·∫° √°nh s√°ng": "#E8B33F",
    "Kh√∫c x·∫° √°nh s√°ng": "#E8B33F",
    "D√≤ng ƒëi·ªán ‚Äì M·∫°ch ƒëi·ªán": "#E8B33F",
    "Nhi·ªát h·ªçc": "#E8B33F",
    "C∆° h·ªçc": "#E8B33F",
    "ƒêi·ªán h·ªçc": "#E8B33F",
    "Quang h·ªçc": "#E8B33F",

    # ‚öóÔ∏è H√ìA H·ªåC
    "Nguy√™n t·ª≠": "#D46A6A",
    "Ph√¢n t·ª≠": "#D46A6A",
    "Nguy√™n t·ªë h√≥a h·ªçc": "#D46A6A",
    "K√≠ hi·ªáu h√≥a h·ªçc": "#D46A6A",
    "C√¥ng th·ª©c h√≥a h·ªçc": "#D46A6A",
    "Ph·∫£n ·ª©ng h√≥a h·ªçc": "#D46A6A",
    "Ph∆∞∆°ng tr√¨nh h√≥a h·ªçc": "#D46A6A",
    "H√≥a tr·ªã": "#D46A6A",
    "Kh·ªëi l∆∞·ª£ng mol": "#D46A6A",
    "Th·ªÉ t√≠ch mol": "#D46A6A",
    "ƒê·ªãnh lu·∫≠t b·∫£o to√†n kh·ªëi l∆∞·ª£ng": "#D46A6A",
    "ƒê·ªãnh lu·∫≠t Avogadro": "#D46A6A",
    "Ch·∫•t tinh khi·∫øt ‚Äì H·ªón h·ª£p": "#D46A6A",
    "Dung d·ªãch": "#D46A6A",
    "N·ªìng ƒë·ªô ph·∫ßn trƒÉm": "#D46A6A",
    "N·ªìng ƒë·ªô mol": "#D46A6A",
    "Ch·∫•t oxi h√≥a ‚Äì Ch·∫•t kh·ª≠": "#D46A6A",
    "Ph·∫£n ·ª©ng oxi h√≥a ‚Äì kh·ª≠": "#D46A6A",
    "Axit ‚Äì Baz∆° ‚Äì Mu·ªëi": "#D46A6A",
    "pH ‚Äì ƒê·ªô axit": "#D46A6A",
    "Kim lo·∫°i ‚Äì Phi kim": "#D46A6A",
    "Oxit ‚Äì Axit ‚Äì Baz∆° ‚Äì Mu·ªëi": "#D46A6A",
    "H√≥a h·ªçc v√¥ c∆°": "#D46A6A",
    "H√≥a h·ªçc h·ªØu c∆°": "#D46A6A",
    "Hiƒërocacbon": "#D46A6A",
    "R∆∞·ª£u ‚Äì Axit cacboxylic": "#D46A6A",
    "Este ‚Äì Ch·∫•t b√©o": "#D46A6A",
    "Gluxit ‚Äì Protein": "#D46A6A",

    # üåø SINH H·ªåC
    "T·∫ø b√†o": "#4FA3A5",
    "M√¥ ‚Äì C∆° quan ‚Äì H·ªá c∆° quan": "#4FA3A5",
    "C∆° th·ªÉ s·ªëng": "#4FA3A5",
    "H√¥ h·∫•p": "#4FA3A5",
    "Tu·∫ßn ho√†n": "#4FA3A5",
    "Ti√™u h√≥a": "#4FA3A5",
    "B√†i ti·∫øt": "#4FA3A5",
    "Th·∫ßn kinh": "#4FA3A5",
    "C·∫£m gi√°c ‚Äì Gi√°c quan": "#4FA3A5",
    "Sinh s·∫£n": "#4FA3A5",
    "Di truy·ªÅn": "#4FA3A5",
    "Bi·∫øn d·ªã": "#4FA3A5",
    "Gen ‚Äì Nhi·ªÖm s·∫Øc th·ªÉ": "#4FA3A5",
    "Quang h·ª£p": "#4FA3A5",
    "H√¥ h·∫•p th·ª±c v·∫≠t": "#4FA3A5",
    "Th·ª±c v·∫≠t ‚Äì ƒê·ªông v·∫≠t": "#4FA3A5",
    "Chu·ªói th·ª©c ƒÉn ‚Äì L∆∞·ªõi th·ª©c ƒÉn": "#4FA3A5",
    "Sinh th√°i h·ªçc": "#4FA3A5",
    "M√¥i tr∆∞·ªùng ‚Äì H·ªá sinh th√°i": "#4FA3A5",
    "Vi sinh v·∫≠t": "#4FA3A5",
    "C·∫•u t·∫°o t·∫ø b√†o": "#4FA3A5",
    "Di·ªÖn bi·∫øn s·ª± s·ªëng": "#4FA3A5",
    "Ti·∫øn h√≥a": "#4FA3A5"
}


# ================== ROUTES ==================
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        name = request.form.get('name', '').strip()  # L·∫§Y T√äN H·ªåC SINH
        if not username or not password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß t√™n ƒëƒÉng nh·∫≠p v√† m·∫≠t kh·∫©u.', 'error')
            return redirect(url_for('register'))
        if not name:
            flash('Vui l√≤ng nh·∫≠p t√™n h·ªçc sinh.', 'error')
            return redirect(url_for('register'))

        if User.query.filter_by(username=username).first():
            flash('T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i.', 'error')
            return redirect(url_for('register'))

        try:
            hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
            user = User(username=username, password=hashed_password, name=name)
            db.session.add(user)
            db.session.commit()
            flash('ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ƒëƒÉng nh·∫≠p.', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {str(e)}")
            flash(f'L·ªói khi ƒëƒÉng k√Ω: {str(e)}', 'error')
            return redirect(url_for('register'))
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        if not username or not password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß t√™n ƒëƒÉng nh·∫≠p v√† m·∫≠t kh·∫©u.', 'error')
            return redirect(url_for('login'))
        user = User.query.filter_by(username=username).first()
        if user and check_password_hash(user.password, password):
            session['user_id'] = user.id
            session['history'] = user.history.split('\n') if user.history else []
            flash('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success')
            return redirect(url_for('index'))
        flash('T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.', 'error')
        return redirect(url_for('login'))
    return render_template('login.html')

@app.route('/logout')
def logout():
    if 'user_id' in session:
        user = db.session.get(User, session['user_id'])
        if user:
            user.history = '\n'.join(session.get('history', []))
            db.session.commit()
            print(f"User {user.username} history updated")
        else:
            print(f"User with ID {session['user_id']} not found")
    session.clear()
    flash('ƒê√£ ƒëƒÉng xu·∫•t th√†nh c√¥ng.', 'success')
    return redirect(url_for('login'))

@app.route('/')
def index():
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ ti·∫øp t·ª•c.', 'error')
        return redirect(url_for('login'))
    rag_status = "‚úÖ ƒê√£ t·∫£i t√†i li·ªáu RAG th√†nh c√¥ng" if RAG_DATA["is_ready"] else "‚ö†Ô∏è Ch∆∞a t·∫£i ƒë∆∞·ª£c t√†i li·ªáu RAG."
    user = db.session.get(User, session['user_id'])
    if not user:
        flash('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.', 'error')
        return redirect(url_for('login'))
    return render_template('index.html', rag_status=rag_status, user_level=user.level)

@app.route('/chat', methods=['POST'])
def chat():
    if 'user_id' not in session:
        return jsonify({'error': 'Vui l√≤ng ƒëƒÉng nh·∫≠p'}), 401

    user_message = request.json.get('message', '')
    if not user_message:
        return jsonify({'response': format_response('Con h√£y nh·∫≠p c√¢u h·ªèi nh√©!')})

    # Load history from session
    history = session.get('history', [])
    history.append(f"üëß H·ªçc sinh: {user_message}")

    # üîç Truy xu·∫•t ng·ªØ c·∫£nh RAG
    related_context = retrieve_context(user_message)
    recent_history = "\n".join(history[-10:])

    # L·∫•y level t·ª´ DB
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 401
    student_level = user.level

    prompt = f"""
    B·∫°n l√† **Th·∫ßy gi√°o Song ng·ªØ Vi·ªát ‚Äì Anh**, chuy√™n d·∫°y c√°c m√¥n **Khoa h·ªçc T·ª± nhi√™n (To√°n, L√Ω, H√≥a, Sinh)**.  
    Gi·ªçng ƒëi·ªáu: th√¢n thi·ªán, kh√≠ch l·ªá, x∆∞ng **‚Äúth·∫ßy ‚Äì con‚Äù**, gi·ªëng nh∆∞ m·ªôt ng∆∞·ªùi th·∫ßy th·∫≠t ƒëang gi·∫£ng b√†i.

    ---

    ### üß† **Th√¥ng tin n·ªÅn:**
    - üìö **T√†i li·ªáu tham kh·∫£o (RAG):**  
    {related_context}
    - üí¨ **L·ªãch s·ª≠ h·ªôi tho·∫°i g·∫ßn ƒë√¢y:**  
    {recent_history}
    - üë®‚Äçüéì **NƒÉng l·ª±c hi·ªán t·∫°i c·ªßa h·ªçc sinh:** {student_level}
    - ‚ùì **C√¢u h·ªèi m·ªõi:** {user_message}

    ---

    ### üéØ **Nhi·ªám v·ª• c·ªßa th·∫ßy:**

    1. **Hi·ªÉu r√µ c√¢u h·ªèi** ‚Äî c√≥ th·ªÉ b·∫±ng **ti·∫øng Vi·ªát**, **ti·∫øng Anh**, ho·∫∑c **c·∫£ hai**.  
    2. **Tr·∫£ l·ªùi song ng·ªØ** theo t·ª´ng c√¢u, t·ª´ng ƒëo·∫°n:
    - Gi·∫£i th√≠ch b·∫±ng **Ti·∫øng Vi·ªát** tr∆∞·ªõc theo t·ª´ng c√¢u, t·ª´ng ƒëo·∫°n.
    - Sau ƒë√≥ vi·∫øt ph·∫ßn d·ªãch t∆∞∆°ng ·ª©ng, m·ªü ƒë·∫ßu b·∫±ng:  
        üëâ <span style="line-height:1.6; background: darkblue; color:white; font-weight:bold; padding:2px 4px; border-radius:4px;">English Version</span>

    3. **Tr√¨nh b√†y c√¥ng th·ª©c, bi·ªÉu th·ª©c khoa h·ªçc b·∫±ng LaTeX**, s·ª≠ d·ª•ng:  
    - `$...$` cho c√¥ng th·ª©c trong d√≤ng  
    - `$$...$$` cho c√¥ng th·ª©c xu·ªëng d√≤ng  
    - Khi xu·ªëng h√†ng, ch·ªâ d√πng th·∫ª `<br>`, kh√¥ng d√πng g·∫°ch ƒë·∫ßu d√≤ng Markdown.
    Format m√†u cho c√°c t·ª´ kh√≥a khoa h·ªçc gi√∫p h·ªçc sinh d·ªÖ d√†ng t√¨m ki·∫øm: {highlight_terms}
    ƒê·ªëi v·ªõi c√°c kh√°i ni·ªám ho·∫∑c t·ª´ kh√≥a ƒë∆∞·ª£c s·ª≠ d·ª•ng, b·ªçc trong th·∫ª <span style="line-height:1.6; background: (m√†u d·ª±a tr√™n highlight_terms); color:white; font-weight:bold; padding:2px 4px; border-radius:4px;">{{term}}</span>

    4. **Tr√¨nh b√†y l·ªùi gi·∫£i theo t·ª´ng b∆∞·ªõc r√µ r√†ng:**
    - Gi·∫£i th√≠ch kh√°i ni·ªám ho·∫∑c ƒë·ªãnh lu·∫≠t li√™n quan.  
    - H∆∞·ªõng d·∫´n c√°ch gi·∫£i n·∫øu l√† b√†i t·∫≠p.  
    - Cho **v√≠ d·ª• t∆∞∆°ng t·ª±** ƒë·ªÉ luy·ªán t·∫≠p.  
    - D·ªãch c√°c **thu·∫≠t ng·ªØ khoa h·ªçc quan tr·ªçng** sang ti·∫øng Anh h·ªçc thu·∫≠t t∆∞∆°ng ·ª©ng.  

    5. **ƒêi·ªÅu ch·ªânh l·ªùi gi·∫£i theo nƒÉng l·ª±c h·ªçc sinh:**
    - üß† **Gi·ªèi (Gioi):** Gi·∫£i th√≠ch s√¢u, m·ªü r·ªông, k√®m b√†i n√¢ng cao.  
    - üí° **Kh√° (Kha):** Gi·∫£i th√≠ch chi ti·∫øt, v√≠ d·ª• minh h·ªça, b√†i t·∫≠p kh√°.  
    - üìò **Trung b√¨nh (TB):** Gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc, v√≠ d·ª• c·ª• th·ªÉ, b√†i t·∫≠p c∆° b·∫£n.  
    - ü™∂ **Y·∫øu (Yeu):** Gi·∫£i th√≠ch th·∫≠t d·ªÖ, d√πng v√≠ d·ª• minh h·ªça r√µ r√†ng, b√†i t·∫≠p nh·∫≠p m√¥n.

    6. **N·∫øu c√¢u tr·∫£ l·ªùi qu√° d√†i:**
    - Gi·ªØ ng·ªØ c·∫£nh li√™n t·ª•c gi·ªØa c√°c ph·∫ßn.  
    - Chia th√†nh `Ph·∫ßn 1`, `Ph·∫ßn 2`, ‚Ä¶  
    - K·∫øt th√∫c m·ªói ph·∫ßn b·∫±ng c√¢u h·ªèi:  
        _‚ÄúCon c√≥ mu·ªën th·∫ßy ti·∫øp t·ª•c sang ph·∫ßn sau kh√¥ng?‚Äù_

    ---

    ### ‚úÖ **Nguy√™n t·∫Øc tr√¨nh b√†y:**
    - Gi·∫£i th√≠ch **ƒë·ªÉ h·ªçc sinh hi·ªÉu ch·ª© kh√¥ng ch·ªâ ƒë·ªÉ tr·∫£ l·ªùi**.  
    - Duy tr√¨ gi·ªçng ƒëi·ªáu t√≠ch c·ª±c, khuy·∫øn kh√≠ch.  
    - D√πng t·ª´ ng·ªØ **chu·∫©n khoa h·ªçc**, **d·ªÖ hi·ªÉu**, **d·ªãch s√°t nghƒ©a**.  
    - Song ng·ªØ t·ª´ng ƒëo·∫°n, gi√∫p h·ªçc sinh luy·ªán ƒë·ªçc hi·ªÉu khoa h·ªçc b·∫±ng ti·∫øng Anh.

    """


    try:
        model = genai.GenerativeModel(GENERATION_MODEL)
        response = model.generate_content(prompt)
        ai_text = response.text

        # L∆∞u tr·∫£ l·ªùi AI v√†o history
        history.append(f"üßë‚Äçüè´ Th·∫ßy/C√¥: {ai_text}")

        # ƒê√°nh gi√° level n·∫øu ƒë·ªß 5 c√¢u h·ªèi m·ªõi
        student_questions = [msg for msg in history if msg.startswith("üëß H·ªçc sinh:")]
        if len(student_questions) % 10 == 0:
            new_level, lydo = evaluate_student_level(history)
            user.level = new_level
            user.lydo = lydo  # l∆∞u l√Ω do v√†o c·ªôt lydo
            db.session.commit()
            print(f"User {user.username} level updated to {new_level} with reason: {lydo}")

        # L∆∞u l·ªãch s·ª≠ c√¢u h·ªèi h·ªçc sinh v√†o session v√† database
        history_questions = student_questions
        # ƒê·∫£m b·∫£o m·ªói tin nh·∫Øn xu·ªëng d√≤ng ri√™ng bi·ªát
        session['history'] = history_questions
        user.history = '\n'.join([msg.strip() for msg in history_questions])  # X√≥a kho·∫£ng tr·∫Øng th·ª´a v√† n·ªëi b·∫±ng \n
        db.session.commit()
        session.modified = True
        print(f"User {user.username} history updated in database: {user.history}")

        return jsonify({'response': format_response(ai_text)})

    except Exception as e:
        print(f"‚ùå L·ªói Gemini: {e}")
        return jsonify({'response': format_response("Th·∫ßy Gemini h∆°i m·ªát, con th·ª≠ l·∫°i sau nh√©!")})
# QU·∫¢N L√ù H·ªåC SINH
@app.route('/admin', methods=['GET', 'POST'])
def admin():
    if 'admin_session' not in session:
        if request.method == 'POST':
            username = request.form.get('username')
            password = request.form.get('password')
            if username == 'lequangphuc':
                user = User.query.filter_by(username=username).first()
                if user and check_password_hash(user.password, password):
                    session['admin_session'] = True
                    flash('ƒêƒÉng nh·∫≠p admin th√†nh c√¥ng!', 'success')
                    return redirect(url_for('admin'))
                else:
                    flash('T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.', 'error')
            else:
                flash('T√™n ƒëƒÉng nh·∫≠p admin kh√¥ng ƒë√∫ng.', 'error')
        return render_template('admin_login.html')
    
    # X·ª≠ l√Ω upload file PDF
    if request.method == 'POST' and 'file' in request.files:
        file = request.files['file']
        if file.filename == '':
            flash('Kh√¥ng c√≥ file ƒë∆∞·ª£c ch·ªçn.', 'error')
        elif file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(file_path)
            flash(f'Upload {filename} th√†nh c√¥ng! ƒê√£ c·∫≠p nh·∫≠t RAG.', 'success')
            initialize_rag_data()
        else:
            flash('Ch·ªâ ch·∫•p nh·∫≠n file PDF!', 'error')
    
    pdf_files = [f for f in os.listdir(app.config['UPLOAD_FOLDER']) if f.endswith('.pdf')] if os.path.exists(app.config['UPLOAD_FOLDER']) else []
    
    # L·∫•y d·ªØ li·ªáu taikhoan_hocsinh + t√™n h·ªçc sinh
    taikhoan_hocsinh = User.query.all()
    user_data = []
    for user in taikhoan_hocsinh:
        user_data.append({
            'id': user.id,
            'username': user.username,
            'name': user.name or "Ch∆∞a ƒë·∫∑t t√™n",  # HI·ªÇN TH·ªä T√äN
            'level': user.level,
            'lydo': user.lydo,
            'history': user.history if user.history else 'Ch∆∞a c√≥ l·ªãch s·ª≠'
        })
    
    return render_template('admin.html', pdf_files=pdf_files, user_data=user_data)

@app.route('/admin/delete_pdf/<filename>', methods=['POST'])
def delete_pdf(filename):
    if 'admin_session' not in session or not session['admin_session']:
        flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.', 'error')
        return redirect(url_for('admin'))
    
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            flash(f'X√≥a file {filename} th√†nh c√¥ng! ƒê√£ c·∫≠p nh·∫≠t RAG.', 'success')
            initialize_rag_data()  # Re-init RAG sau khi x√≥a
        except Exception as e:
            flash(f'L·ªói khi x√≥a file {filename}: {str(e)}', 'error')
    else:
        flash(f'File {filename} kh√¥ng t·ªìn t·∫°i.', 'error')
    
    return redirect(url_for('admin'))

@app.route('/admin/export_csv')
def export_csv():
    if 'admin_session' not in session or not session['admin_session']:
        flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.', 'error')
        return redirect(url_for('admin'))
    
    taikhoan_hocsinh = User.query.all()
    user_data = []
    for user in taikhoan_hocsinh:
        user_data.append({
            'ID': user.id,
            'T√™n ƒëƒÉng nh·∫≠p': user.username,
            'T√™n h·ªçc sinh': user.name or "Ch∆∞a ƒë·∫∑t t√™n",  # TH√äM C·ªòT T√äN
            'NƒÉng l·ª±c': user.level,
            'L√Ω do': user.lydo,
            'L·ªãch s·ª≠': user.history if user.history else 'Ch∆∞a c√≥ l·ªãch s·ª≠'
        })
    
    df = pd.DataFrame(user_data)
    output = BytesIO()
    df.to_csv(output, index=False, encoding='utf-8-sig')
    output.seek(0)
    
    return send_file(
        output,
        mimetype='text/csv',
        as_attachment=True,
        download_name='ket_qua_hoc_tap.csv'
    )
@app.route('/admin/logout')
def admin_logout():
    session.pop('admin_session', None)
    flash('ƒê√£ ƒëƒÉng xu·∫•t admin.', 'success')
    return redirect(url_for('admin'))

# ================== CH·∫†Y APP ==================
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)